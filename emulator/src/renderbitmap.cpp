// *******************************************************************************************************************************
// *******************************************************************************************************************************
//
//		Name:		renderbitmap.cpp
//		Purpose:	Render bitmap display
//		Created:	27th February 2022
//		Author:		Paul Robson (paul@robsons.org.uk)
//
// *******************************************************************************************************************************
// *******************************************************************************************************************************

#include <includes.h>

// *******************************************************************************************************************************
//													Read long from BYTE *
// *******************************************************************************************************************************

LONG32 HWReadLong(BYTE8 *p) {
	return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}

// *******************************************************************************************************************************
//													Render text screen
// *******************************************************************************************************************************

void HWRenderBitmap(DISPLAYINFO *d,BYTE8 *vicky,BYTE8 *videoMem,int bitmapID) {

	if ((vicky[3] & 0x08) == 0) return; 				// No bitmap mode enabled.
	if ((vicky[0x103] & 0x01) == 0) return; 			// Layer not enabled.

	int scaling = (vicky[2] & 4) ? 2 : 1; 				// scaling.

	int convLuts[256]; 									// Convert LUTs when needed.
	for (int i = 0;i < 256;i++) convLuts[i] = -1;

	SDL_Rect rc;

	BYTE8 *pixData = videoMem;
	pixData += HWReadLong(vicky+0x104); 				// Start of bitmap data.

	int baseLut = ((vicky[0x103] >> 1) & 7) * 0x400;	// Which LUT set ?

	int xSize = d->dWidth/scaling; 						// Pixels to draw
	int ySize = d->dHeight/scaling;

	for (int y = 0;y < ySize;y++) {
		rc.x = d->rcDraw.x;rc.y = d->rcDraw.y+y*d->pSize*scaling;
		rc.w = rc.h = d->pSize * scaling;		
		for (int x = 0;x < xSize;x++) {
			int col = pixData[x];
				if (col != 0) {
					if (convLuts[col] < 0) {
						convLuts[col] = HWConvertVickyBitmapLUT(vicky+0x2000+baseLut+col*4);
					}
					GFXRectangle(&rc,convLuts[col]);
			}
			rc.x += rc.w;
		}
		pixData += d->dWidth/scaling;
	}
}

// *******************************************************************************************************************************
// *******************************************************************************************************************************
//
//		Changes made
//	
//		Date 			Changes
//		---- 			-------
//		11-Mar-22 		Code reorganisation to allow overlay
//		12-Mar-22 		Handle double size display
//
// *******************************************************************************************************************************
// *******************************************************************************************************************************
